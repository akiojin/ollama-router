# Publish Workflow
# 由来: release-binaries.yml + claude-worktree/publish.yml統合
# 目的: mainへのpush時にバイナリをビルド・公開し、developへbackmerge
# トリガー: main push (chore(release): コミット) または手動実行

name: Publish

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag to publish (defaults to latest tag)"
        required: false

permissions:
  contents: write
  pull-requests: write

jobs:
  detect-release:
    name: Resolve release tag
    runs-on: ubuntu-latest
    if: "!contains(github.event.head_commit.message, '[skip ci]')"
    outputs:
      release_tag: ${{ steps.resolve.outputs.release_tag }}
      is_release: ${{ steps.resolve.outputs.is_release }}
      release_version: ${{ steps.resolve.outputs.release_version }}
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Resolve tag
        id: resolve
        env:
          INPUT_TAG: ${{ github.event.inputs.release_tag || '' }}
        run: |
          set -euo pipefail

          # Check if this is a release commit
          if git log -1 --pretty=%B | grep -q '^chore(release):'; then
            echo "is_release=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_release=false" >> "$GITHUB_OUTPUT"
          fi

          # Determine release tag
          if [[ -n "$INPUT_TAG" ]]; then
            tag="$INPUT_TAG"
          else
            # Extract version from commit message (e.g., "chore(release): merge v2.0.5 to main")
            commit_msg=$(git log -1 --pretty=%B)
            tag=$(echo "$commit_msg" | grep -oP 'v\d+\.\d+\.\d+' | head -1 || true)

            # Fallback to git describe if version not found in commit message
            if [[ -z "$tag" ]]; then
              git fetch --tags --force
              tag=$(git describe --tags --abbrev=0 || true)
            fi
          fi

          if [[ -z "$tag" ]]; then
            echo "No release tag detected; skipping publish run"
            echo "release_tag=" >> "$GITHUB_OUTPUT"
            echo "release_version=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Resolved release tag: $tag"
          echo "release_tag=$tag" >> "$GITHUB_OUTPUT"

          sanitized="${tag#v}"
          sanitized="${sanitized%%-*}"
          if [[ -z "$sanitized" ]]; then
            sanitized="0.0.0"
          fi
          echo "release_version=$sanitized" >> "$GITHUB_OUTPUT"

  build-binaries:
    name: Build ${{ matrix.artifact }}
    needs: detect-release
    if: needs.detect-release.outputs.is_release == 'true' && needs.detect-release.outputs.release_tag != ''
    runs-on: ${{ matrix.os }}
    env:
      RELEASE_TAG: ${{ needs.detect-release.outputs.release_tag }}
      RELEASE_VERSION: ${{ needs.detect-release.outputs.release_version }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact: linux-x86_64
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            artifact: windows-x86_64
          - os: macos-15-intel
            target: x86_64-apple-darwin
            artifact: macos-x86_64
          - os: macos-latest
            target: aarch64-apple-darwin
            artifact: macos-arm64
    steps:
      - name: Checkout sources
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Configure macOS toolchain
        if: matrix.target == 'aarch64-apple-darwin'
        shell: bash
        run: |
          echo "CARGO_TARGET_AARCH64_APPLE_DARWIN_LINKER=clang" >> $GITHUB_ENV
          echo "CC_aarch64_apple_darwin=clang" >> $GITHUB_ENV
          echo "CXX_aarch64_apple_darwin=clang++" >> $GITHUB_ENV

      - name: Configure macOS toolchain (x86_64)
        if: matrix.target == 'x86_64-apple-darwin'
        shell: bash
        run: |
          echo "CARGO_TARGET_X86_64_APPLE_DARWIN_LINKER=clang" >> $GITHUB_ENV
          echo "CC_x86_64_apple_darwin=clang" >> $GITHUB_ENV
          echo "CXX_x86_64_apple_darwin=clang++" >> $GITHUB_ENV

      - name: Build release binaries
        run: cargo build --release --target ${{ matrix.target }} -p or-router -p or-node

      - name: Install WiX Toolset
        if: runner.os == 'Windows'
        shell: pwsh
        run: choco install wixtoolset --version 3.11.2 -y --allow-downgrade --force

      - name: Package binaries (Unix)
        if: runner.os != 'Windows'
        id: package_unix
        shell: bash
        run: |
          set -euo pipefail
          archive="ollama-router-${{ matrix.artifact }}.tar.gz"
          staging="dist/ollama-router-${{ matrix.artifact }}"
          mkdir -p "$staging"
          cp "target/${{ matrix.target }}/release/or-router" "$staging/"
          cp "target/${{ matrix.target }}/release/or-node" "$staging/"
          cp README.md README.ja.md LICENSE "$staging/"
          tar czf "$archive" -C dist "$(basename "$staging")"
          echo "archive=$archive" >> "$GITHUB_OUTPUT"

      - name: Validate archive contents (Unix)
        if: runner.os != 'Windows'
        shell: bash
        run: |
          set -uo pipefail
          archive="${{ steps.package_unix.outputs.archive }}"
          [[ "$archive" == ollama-router-* ]] || { echo "::error::unexpected archive name $archive"; exit 1; }
          [[ "$archive" == *.tar.gz ]] || { echo "::error::expected .tar.gz archive"; exit 1; }
          set +o pipefail
          root_dir=$(tar -tzf "$archive" 2>&1 | head -1 | cut -d/ -f1)
          set -o pipefail
          [[ -n "$root_dir" ]] || { echo "::error::failed to detect root directory"; exit 1; }
          tar -tzf "$archive" > contents.txt 2>&1
          grep -q "^${root_dir}/or-router\$" contents.txt || { echo "::error::or-router not found"; exit 1; }
          grep -q "^${root_dir}/or-node\$" contents.txt || { echo "::error::or-node not found"; exit 1; }
          grep -q "^${root_dir}/README.md\$" contents.txt || { echo "::error::README.md not found"; exit 1; }
          grep -q "^${root_dir}/README.ja.md\$" contents.txt || { echo "::error::README.ja.md not found"; exit 1; }
          grep -q "^${root_dir}/LICENSE\$" contents.txt || { echo "::error::LICENSE not found"; exit 1; }
          rm contents.txt

      - name: Package binaries (Windows)
        if: runner.os == 'Windows'
        id: package_windows
        shell: pwsh
        run: |
          $archive = "ollama-router-${{ matrix.artifact }}.zip"
          $staging = Join-Path "dist" "ollama-router-${{ matrix.artifact }}"
          New-Item -ItemType Directory -Path $staging -Force | Out-Null
          Copy-Item "target/${{ matrix.target }}/release/or-router.exe" $staging
          Copy-Item "target/${{ matrix.target }}/release/or-node.exe" $staging
          Copy-Item README.md,README.ja.md,LICENSE $staging
          Compress-Archive -Path (Join-Path $staging '*') -DestinationPath $archive -Force
          "archive=$archive" >> $env:GITHUB_OUTPUT

      - name: Validate archive contents (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $archive = "${{ steps.package_windows.outputs.archive }}"
          if (-not ($archive -like "ollama-router-*")) {
            Write-Error "unexpected archive name $archive"
            exit 1
          }
          if (-not ($archive.EndsWith(".zip"))) {
            Write-Error "expected .zip archive"
            exit 1
          }
          $extractDir = Join-Path $PWD "validate"
          if (Test-Path $extractDir) {
            Remove-Item $extractDir -Recurse -Force
          }
          Expand-Archive -Path $archive -DestinationPath $extractDir -Force
          $files = Get-ChildItem -Path $extractDir -File -Recurse
          $binaryPrefixes = @("or-router","or-node")
          foreach ($prefix in $binaryPrefixes) {
            if (-not ($files.Name | Where-Object { $_ -like "$prefix*.exe" })) {
              Write-Error "missing executable matching $prefix*.exe in archive"
              exit 1
            }
          }
          $staticFiles = @("README.md","README.ja.md","LICENSE")
          foreach ($name in $staticFiles) {
            if (-not ($files.Name -contains $name)) {
              Write-Error "missing $name in archive"
              exit 1
            }
          }
          Remove-Item $extractDir -Recurse -Force

      - name: Build macOS installer (.pkg)
        if: matrix.target == 'x86_64-apple-darwin' || matrix.target == 'aarch64-apple-darwin'
        id: package_macos_installer
        shell: bash
        run: |
          set -euo pipefail
          version="${RELEASE_VERSION}"
          if [[ -z "$version" ]]; then
            echo "::error::Release version is not available."
            exit 1
          fi
          pkg_root="$(pwd)/pkgroot"
          install_dir="$pkg_root/usr/local/bin"
          mkdir -p "$install_dir"
          install -m 0755 "target/${{ matrix.target }}/release/or-router" "$install_dir/"
          install -m 0755 "target/${{ matrix.target }}/release/or-node" "$install_dir/"
          pkg_name="ollama-router-${{ matrix.artifact }}.pkg"
          pkgbuild \
            --root "$pkg_root" \
            --identifier "io.ollama.router" \
            --version "$version" \
            --install-location "/" \
            "$pkg_name"
          rm -rf "$pkg_root"
          echo "pkg=$pkg_name" >> "$GITHUB_OUTPUT"

      - name: Build Windows installer (.msi)
        if: runner.os == 'Windows'
        id: package_windows_installer
        shell: pwsh
        run: |
          $version = "${env:RELEASE_VERSION}"
          if ([string]::IsNullOrEmpty($version)) {
            Write-Error "Release version is not available."
            exit 1
          }
          $binaryDir = Join-Path $PWD "target/${{ matrix.target }}/release"
          $wxs = Join-Path $PWD "installers/windows/ollama-router.wxs"
          $obj = "ollama-router.wixobj"
          $msi = "ollama-router-${{ matrix.artifact }}.msi"
          $wixPath = "${env:ProgramFiles(x86)}\WiX Toolset v3.11\bin"
          $env:PATH = "$wixPath;$env:PATH"
          candle.exe $wxs -out $obj -dBinariesDir="$binaryDir" -dProductVersion="$version"
          light.exe $obj -out $msi -sice:ICE03
          "msi=$msi" >> $env:GITHUB_OUTPUT

      - name: Upload release artifact (Unix)
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: ${{ steps.package_unix.outputs.archive }}
          if-no-files-found: error

      - name: Upload release artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: ${{ steps.package_windows.outputs.archive }}
          if-no-files-found: error

      - name: Upload macOS installer artifact
        if: (matrix.target == 'x86_64-apple-darwin' || matrix.target == 'aarch64-apple-darwin') && steps.package_macos_installer.outputs.pkg != ''
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}-pkg
          path: ${{ steps.package_macos_installer.outputs.pkg }}
          if-no-files-found: error

      - name: Upload Windows installer artifact
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}-msi
          path: ${{ steps.package_windows_installer.outputs.msi }}
          if-no-files-found: error

  publish-binaries:
    name: Attach binaries to GitHub Release
    needs: [detect-release, build-binaries]
    if: needs.detect-release.outputs.is_release == 'true' && needs.detect-release.outputs.release_tag != ''
    runs-on: ubuntu-latest
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release
          merge-multiple: true

      - name: List downloaded assets
        run: ls -R release

      - name: Upload assets to GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.detect-release.outputs.release_tag }}
          files: release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  backmerge-to-develop:
    name: Backmerge to develop
    needs: [detect-release]
    if: needs.detect-release.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Backmerge main to develop
        run: |
          echo "Checking out develop..."
          git fetch origin develop
          git checkout develop

          echo "Merging main to develop..."
          git merge origin/main --no-edit -m "chore: Backmerge main to develop [skip ci]"

          echo "Pushing to develop..."
          git push origin develop
